<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA['随记']]></title>
    <url>%2F2018%2F03%2F19%2F%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[随记js代码中可以直接修改元素的样式[^无论是样式表还是内联样式]，但是不能通过直接的方式获取在样式表内定义的样式 123456789101112131415&lt;style&gt; div&#123; position: absolute; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;/html&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.style.width) //无结果 //只能通过getComputedStyle()来获取，这个函数获取样式，不能修改样式 var width = window.getComputedStyle(div).width //100px clientWidth = width + padding offsetWidth = width + padding +border offsetLeft表示自身左侧到offsetParent(离自身最近的有定位position的父元素，若没有则为body)左侧的距离。 offsetLeft = left + margin-left 12345&lt;html&gt; &lt;div id='father'&gt; &lt;div id='son'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/html&gt; offsetParent有定位, 本身也有定位 123456789101112131415&lt;style&gt; #father &#123; position: relative/absolute; padding: 20px; &#125; #son &#123; position: relative/absolute;/*定位*/ left: 100px; margin-left: 20px; &#125;&lt;style&gt;&lt;script&gt; console.log(son.offsetLeft) // 120 son.offsetLeft = 100 + 20&lt;/script&gt; offsetParent有定位，本身没有定位 12345678910111213141516&lt;style&gt; #father &#123; position: relative/absolute; padding: 20px; &#125; #son &#123; position: relative/absolute; left: 100px; margin-left: 20px; &#125;&lt;style&gt;&lt;script&gt; console.log(son.offsetLeft) // 40 son.offsetLeft = margin-left + father.padding-left = 20 + 20 &lt;/script&gt; ​ 关于prototyep和__proto__]]></content>
      <tags>
        <tag>prototyep和__proto__</tag>
        <tag>offsetWidth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数去重]]></title>
    <url>%2F2017%2F11%2F24%2Fjs%E5%87%BD%E6%95%B0%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[方法1：利用indexof 12345678910var a = [1,3,4,5,3,3];function arr(a)&#123; var res = []; for(var i=0; i&lt;a.length; i++)&#123; if(res.indexOf(a[i]) == -1)&#123; res.push(a[i]); &#125; &#125; return res;&#125; 优化后： 123456789Array.prototype.arr = function()&#123; var res = []; for(var i=0; i&lt;this.length; i++)&#123; if(res.indexOf(this[i]) == -1)&#123; res.push(this[i]); &#125; &#125; return res;&#125; 方法2： 1.创建一个新的数组存放结果 2.创建一个空对象 3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。 1234567891011Array.prototype.unique = function()&#123; var res = []; var j = &#123;&#125;; for(var i=0; i&lt;this.length; i++)&#123; if(!j[this[i]])&#123; res.push(this[i]); j[i] = 1; &#125; &#125; return res;&#125;]]></content>
      <tags>
        <tag>数组</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element与Node区别、children与childNodes区别]]></title>
    <url>%2F2017%2F11%2F23%2FElement%E4%B8%8ENode%E5%8C%BA%E5%88%AB%E3%80%81children%E4%B8%8EchildNodes%E5%8C%BA%E5%88%AB-1%2F</url>
    <content type="text"><![CDATA[JavaScript中Element与Node的区别，children与childNodes的区别Element继承了Node类，也就是Element是Node多种类型中的一种。 document.getElementById(‘xx’)取得的是Node还是Element呢？ 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt; &lt;p&gt;One&lt;/p&gt; &lt;p&gt;Two&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; var div = document.getElementById("test"); //true console.log(div instanceof Element); //true console.log(div instanceof Node);&lt;/script&gt; 可以看出document.getElementById(‘xx’)获取的即是Node也是Element。 children是Element的属性，childNodes是Node的属性： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt; &lt;p&gt;One&lt;/p&gt; &lt;p&gt;Two&lt;/p&gt; &lt;/div&gt; &lt;p&gt;Three&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; var div = document.getElementById("test"); console.log(div.children[0] instanceof Element); //true console.log(div.children[0] instanceof Node); //true console.log(div.childNodes[0] instanceof Element); //false console.log(div.childNodes[0] instanceof Node); //true console.log(typeof div.childNodes[0].children); //undefined console.log(typeof div.childNodes[0].childNodes); //object&lt;/script&gt; Element.childern返回[object HTMLCollection]数组，上面例子的 body.childern = [object HTMLCollection];//[&#39;div&#39;,&#39;p&#39;,&#39;script&#39;] Element.childNodes返回[object NodeList]数组， body.childNodes = [object NodeList] //[&#39;#text&#39;,&#39;div&#39;,&#39;#text&#39;,&#39;script&#39;,&#39;#text&#39;]]]></content>
      <tags>
        <tag>Element</tag>
        <tag>children</tag>
        <tag>childNodes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js学习笔记]]></title>
    <url>%2F2017%2F11%2F05%2FJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数值1.1整数和浮点数js内部，所有的数字都是以64为浮点数的形式存储的，整数也是如此，所以1与1.0是相同的一个数。 1 === 1.0 // true 浮点数不是精确的值： 1230.1 + 0.2 === 0.3 //false0.3 / 0.1 //2.9999999999996(0.3 - 0.2) === (0.2 - 0.1) // false ### 1.2数值精度 范围：-(2^{53} - 1) ～ 2^53 -1 12345Math.pow(2, 53) //9007199254740992Math.pow(2, 53) + 1 // 9007199254740992Math.pow(2, 53) + 2 // 9007199254740994Math.pow(2, 53) + 3 // 9007199254740996Math.pow(2, 53) + 4 // 9007199254740996 大于2的53次方以后，整数运算的结果开始出现错误。 １.３正零和负零js中存在2个0：+0, -0,他们是等价的。12345-0 === +0 //true0 === +0 //true0 === -0 //true(+0).toString() //'0'(-0).String() //'0' 唯一区别在于，+0,-0为分母时 1(1 / -0) === (1 / +0) //false 1.4 NaNNaN: 表示“非数字”（NOT a Number） 1typeof NaN //'number' NaN不等于任何值，包括它本身 1NaN === NaN //false 判断NaN的方法： isNaN 12345678910111213isNaN(NaN) //trueisNaN(123) //falseisNaN('Hello') //true//相当于isNaN(Number('Hello'))//trueisNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN(['xzy']) // true// 等同于isNaN(Number(['xzy'])) // true 对于空数组和只有一个成员的数组，isNaN返回false,因为这些数组能被Number函数转换成数值。 123isNaN([]) //falseiisNAN([123]) //falseisNaN(['123']) //false 1.5 parseInt()parseIn方法将字符串转为整数,第一个参数为字符串，如果不是字符串，会先转化为字符串，第二个参数（2到36）表示被解析的值的进制，默认情况下为10. 1234567parseInt('123') //123parseInt(1.23) // 1// 等同于parseInt('1.23') // 1parseInt('1000', 2) // 8parseInt('1000', 6) // 216parseInt('1000', 8) // 512 1.6 parseFloat()parseFloat方法用于及那个一个字符串转化为浮点数。 1parseFloat('3.14') //3.14 对象1.1 对象的键名对象的键名都是字符串，所以加不加引号都可以。 1234var o = &#123; &apos;p&apos;: &apos;Hello World&apos; a: &apos;Hello World&apos;&#125; 如果键名是数值，会自动转化为字符串。 12345678910var o = &#123; 1: 'a', 3.2: 'b', 1e2: 'c'&#125;// Object &#123;// 1: "a",// 3.2: "b",// 100: "c",//&#125; 1.2 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a //1o2.b = 2;o1.b //2 此时取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 //&#123;&#125; 原始类型的数据则是传值引用，也就是值得的拷贝 12345var x = 1;var y = x;x = 2;y //1 1.4表达式&amp;&amp;语句 行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 12eval('&#123;foo: 123&#125;') //123eval('(&#123;foo: 123&#125;)') //&#123;foo: 123&#125; 1.5 查看所有属性Object.keys方法 123456var o = &#123; key1: 1, key2: 2&#125;;Object.keys(o)//['key1', 'key2'] 1.6 delete命令delete命令用于删除对象的属性，删除成功后返回true 123456var o = &#123;p: 1&#125;;Object.keys(o) // ["p"]delete o.p //trueo.p //undefinedObject.keys(o) //[] delete命令不能删除var命令声明的变量，只能用来删除属性。 123var p = 1;delete p // falsedelete window.p //false 1.7 in运算符判断全局变量x是否存在 123if(x)&#123; return 1; &#125; //falseif(window.x)&#123; return 1; &#125; //若x存在但值为falseif('x' in window)&#123; return 1;&#125; //true in有一个问题，不能识别对象继承的属性 123var o = new Object();o.hasOwnProterty('toString') //false'toString' in o //true toString 方法不是对象ｏ自身的属性，而是继承的属性，hasOwnProperty方法可以说明这一点，但是，in运算符不能识别，对继承的属性也返回true。 1.8 for…in循环1234567var o = &#123;a:1, b:2,c:3&#125;;for(var i in o)&#123; console.log(o[i]);&#125;//1//2//3 它遍历的是所有的可遍历的属性，会跳过不可遍历的属性，不仅遍历自身的属性，还遍历继的属性。 数组1.1 length数组本身是对象的一种，所以我们可以为数组添加属性，但这不影响length属性。 123456var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length //0a[2.1] = &apos;abc&apos;;a.length //0 1.2 for…infor..in 不仅会遍历所有的数字键，还会遍历非数字键。 12345678910var a = [1,2,3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;//0//1//2//foo 1.3 数组的空位空位不会影响length属性。 123var a = [1, ,1];a.length //3a[1] //undefined 使用delete命令删除一个数组成员，会形成空位，但不会影响length属性。 1234var a = [1,2,3];delete a[1];a[1] //undefineda.length //3 数组的某个位置是空位，使用数组的forEach方法，for ..in结构，以及Object.keys方法进行遍历，空位都会被跳过。 1234567891011var a = [,,,];a.forEach(function(x, i) &#123; console.log(i + '.' + x);&#125;)//不产生任何输出for(var i in a)&#123; console.log(i)&#125;//不产生任何输出Object.keys(a) //[] 如果某个位置是undefined，遍历的时候就不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + '. ' + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// ['0', '1', '2'] 函数1.1 函数名的提升Js引擎及将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 12f();function f()&#123;&#125; 表面上，上面的代码好像在声明之前就调用了函数f。但实际上，由于“变量提升”，函数f被提升到了代码头部，也就是调用之前已经声明了。但是，如果采用赋值语句定义函数，JsvaScript就会报错。 12345678f();var f = function()&#123;&#125;;// TypeError: undefined is not a function//等同于var f;f();f = function()&#123;&#125;; 上面代码中调用f的时候，f只是被声明，还没有被赋值，等于unddfined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 12345678var f = function() &#123; console.log('1');&#125;function f() &#123; console.log('2');&#125;f() //1 1.2 length属性length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b)&#123;&#125;f.length //2 1.3 toSting()函数的toString方法返回函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 1.4 函数内部的变量推升函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x)&#123; if(x &gt; 100)&#123; var tem = x - 100; &#125;&#125;//Uncaught ReferenceError: tem is not defined//等同于function foo(x)&#123; var tem; if(xx &gt; 100)&#123; tem = x - 100; &#125;&#125; 1.5 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 12345678910var a = 1;var x = function() &#123; coonsole.log(a);&#125;;function f()&#123; var a = 2; x();&#125;f() //1 上面的代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量(函数x中的a)a不会到函数f体内取值，所以输出1，而不是2. 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 12345678910var x = function()&#123; console.log(a);&#125;;function y(f)&#123; var a = 2; f();&#125;y(x);//ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 1.7 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递。这意味着，在函数体内修改参数的值，不会影响到函数外部。 1234567var p = 2;function f(p)&#123; p = 3;&#125;f(p);p //2 但是，如果函数参数是复合类型的值（数值、对象、其他函数），传址传递，也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 12345678var obj = &#123;P: 1&#125;;function f(o)&#123; o.p = 2;&#125;f(obj);obj.p //2 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 123456789var obj = [1,2,3];function f(o)&#123; o = [2,3,4];&#125;f(obj);obj //[1,2,3]//函数内部 ｏ＝ｏｂｊ 1.8 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a)&#123; console.log(a);&#125;f(1,2) //2f(1) //undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。 12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 1.8 arguments对象arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数。 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b)&#123; arguments[0] = 3; arguments[1] = 2; return a+b;&#125;f(1,1) //5 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b)&#123; 'use strict'; arguments[0] = 3; arguments[1] = 2; return a+b;&#125;f(1,1) //2 arguments对象的length属性，判断函数调用时到底带几个参数。 1234567var f = function()&#123; return arguments.length&#125;f(1,2,3) //3f(1) //1f() //0 ###1.9 eval命令 eval命令的作用就是，将字符串当作语句执行。 12eval('var a = 1;')a //1 eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。 123var a =1;exal('a=2');a//2 上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。 为了防止这种风险，JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 12345(function f() &#123; 'use strict'; eval('var foo = 123'); console.log(foo); // ReferenceError: foo is not defined&#125;)() 上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。 不过，即使在严格模式下，eval依然可以读写当前作用域的变量。 123456(function f() &#123; 'use strict'; var foo = 1; eval('foo = 2'); console.log(foo); // 2&#125;)() 运算符1.1 加法运算符加法运算符‘+’，既可以作为算术的加法，也可作为字符串的连接。 1234561 + 1 //2true + true //2//字符串连接'1' + '1' //"11"'1.1' + '1.1' //"1.11.1" 它的算法步骤： 1.如果运算子是对象，先自动转化成原始类型的值（即先执行该对象的vauleOf方法，如果结果还不是原始类型的值，再执行toString方法；如果对象是Date实例，则先执行toString方法）。 2.两个运算子都是原始类型的值以后，只要一个运算子是字符串，则两个运算子都转化为字符串，执行字符串连接运算。 3.否则，两个运算子都转化为数值，执行加法运算。 1234'1' + &#123;foo: 'bar'&#125; //"1[object,object]"'1' + 1 //"11"'1' + true //"1true"'1' + [2] //"12" 下面的写法，可以用来将一个值转化为字符串 1x + '' 123456789[1,2] + [3]//"1,23"//等同于String([1,2]) + String([3]) //'1,2' + '3'var now = new Date();typeof(now + 1) //"String"typeof(now - 1) //"Number" 对象是Date实例，则先执行toString方法 1.2 算术运算符比较运算符######1 字符串的比较 JavaScript 引擎内部首先比较首字符的 Unicode 码点，如果相等，再比较第二个字符的 Unicode 码点，以此类推。 123'cat' &gt; 'dog' //false'cat' &gt; 'catalog' //false'cat' &gt; 'Cat' //true 上面代码中，小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。 2 非字符串的比较(1)原始类型的值 两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===)，其他比较运算符都是先转成数值再比较。 12345675 &gt; '4' //true//等同于 5 &gt; Number('4')//即 5 &gt; 42 &gt; true //true//等同于 2 &gt; Number(true) //即 2 &gt; 1 (2)对象 如果运算子是对象，会先转化为原始类型的值，再进行比较。 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，详细解释参见《数据类型的转换》一节。 1234var x = [2];x &gt; '11' //true//等同于 [2].valueOf().toString() &gt; '11'//即 '2' &gt; '11' 两个对象之间的比较也是如此。 1234567[2] &gt; [1] //true//等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()//即 '2' &gt; '1'&#123;x: 2&#125; &gt;= &#123;x: 1&#125; //true//等同于 &#123;x: 2&#125;.valueOf().toString() &gt; &#123;x: 2&#125;.valueOf().toString()//即 '[object,object]' &gt;= '[object,object]' （3）对象与原始类型值比较== 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。 12345678[1] == 1 //true//等同于 Number([1]) == 1[1] == '1' //true//等同于 Number([1]) == Number('1')[1] == true // true// 等同于 Number([1]) == Number(true) 对于比较运算的总结： 两个运算子一个为数值的话，另一个先转化为数值类型再比较用Number()方法。 12345672 &gt; ['11'] //false//等同于 2 &gt; Number(['11'])//即 2 &gt; 111 == [1]//等同于 1 == Number([1])//即 1 == 1 2.一个运算子为字符串，另一个为对象，则将对象会转为原始类型的值（字符串），再进行比较。 1234567var x = [2];x &gt; '11' // true// 等同于 [2].valueOf().toString() &gt; '11'// 即 '2' &gt; '11'[1] == '1' // true// 等同于 String([1]) == '1' 3.对象与对象 1234567[2] &gt; [1] //true//等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()//即 '2' &gt; '1'&#123;x: 2&#125; &gt;= &#123;x: 1&#125; //true//等同于 &#123;x: 2&#125;.valueOf().toString() &gt; &#123;x: 2&#125;.valueOf().toString()//即 '[object,object]' &gt;= '[object,object]' DOM事件分为五类： HTML事件：事件触发函数绑定在html元素里，html与script高度耦合。一旦修改就得修改两个地方。 123456&lt;input type='text' onclick='show()'&gt;&lt;script&gt; function show()&#123; alert(this.nodeName) &#125;&lt;/script&gt; DOM 0级事件：HTML与script完全分离，事件的定义和触发都在脚本文件中执行。 1234567&lt;input type='text' id='t1'&gt;&lt;script&gt; var t1 = document.getElementById('t1'); t1.onclick = function()&#123; alert(this.nodeName); &#125;&lt;/script&gt; ​ DOM 2级事件：使用addEventListener(type, fun, boolean)添加事件和removeEventListener(type, fun, boolean)删除事件。 123456789&lt;input type='text' id='t1'&gt;&lt;script&gt; var t1 = document.getElementById('t1'); function f()&#123; alert(this.nodeName); &#125; t1.addEventListener('click', f, false); t1.removeEventListener('click', f, false);&lt;/script&gt; false: 默认冒泡 IE事件(本身支持冒泡事件)：IE浏览器添加事件attachEvent(type, fun)和删除事件detachEvent(type,fun) 123456789&lt;input type='text' id='t1'&gt;&lt;script&gt; var t1 = document.getElementById('t1'); function f()&#123; alert(this.nodeName); &#125; t1.attachEvent('onclick', f); t1.detachEvent('onclick', f);&lt;/script&gt; ​ 跨浏览器事件处理：封装一个类，兼容DOM与IE事件 12345678910111213141516171819202122var Handle = &#123; //添加事件 addHandle: function(element, type, f)&#123; if(element.addEventListener)&#123; element.addEventListener(type, f, false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on'+type, f); &#125;else&#123; element.['on'+type] = f; &#125; &#125; //删除事件 deleteHandle: function(element, type, f)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type, f, false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on'+type, f); &#125;else&#123; element['on'+type] = null; &#125; &#125;&#125; ​ ​]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模式:content-box]]></title>
    <url>%2F2017%2F10%2F26%2FCSS%E7%9B%92%E6%A8%A1%E5%BC%8F-content-box%2F</url>
    <content type="text"><![CDATA[盒模型：每个HLML标签都是一个方块，然后这些 方块里又包含着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。 ##盒模型分为：W3C标准盒模型和IE盒模型 W3C标准盒模型：属性width和height只包含content内容，不包括padding和border。 IE盒模型：属性width和height包含padding和border，即content+padding+border。w3c盒模型： 12345.box &#123; width: 200px; height: 200px; background-color: pink;&#125; 123456.box &#123; width: 200px; height: 200px; padding: 10px; background-color: pink;&#125; 此时盒子的长宽变成了220×220，显然padding是能改变盒子的大小的，这时盒子的大小等于content+padding。我们在编写代码时应尽量使用标准的W3C模型（需在页面中声明DOCTYPE类型），这样可以避免多个浏览器对同一个页面不支持。]]></content>
      <tags>
        <tag>css盒模式</tag>
        <tag>conten-box</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose查询.exec()返回promise对象]]></title>
    <url>%2F2017%2F10%2F18%2Farticle1%2F</url>
    <content type="text"><![CDATA[关于Mongoose中model.find()查询的疑惑： 12model.find().exec()//exec()返回一个完整的promise对象 mongoose的所有查询操作返回的结果都是query（官方文档是这样写的），并非一个完整的promise。而加上.exec() 则会返回一个完整的promise对象，但是这其实是mongoose自行封装的promise与 ES6 标准的 promise 是有所出入的（你应该会在控制台看到相关的警告），而且官方也明确指出，在未来的版本将会废除自行封装的promise，改为 ES6 标准，因此建议楼主在使用过程中替换为 ES6 的 promise，如下： 12const mongoose = require('mongoose');mongoose.Promise = global.Promise; 12345678async function()&#123; let result = await Article .find() .sort(&#123;'createTime': -1&#125;) .exec() .catch(err =&gt; &#123; ctx.throw(500, '服务器内部错误-查询所有文章错 误！');&#125; 上面的代码是异步获取数据库中的所有文章 async表示这是一个async函数，await只能在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的是一个exec()返回的promise对象运行结果是 rejected的话，由catch捕获错误，运行结果是resolve的话，结果赋给result]]></content>
      <tags>
        <tag>mongoose</tag>
        <tag>exec()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my new post]]></title>
    <url>%2F2017%2F09%2F24%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[追光者_岑宁儿 #这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上，在之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。CSS书写顺序 1.位置属性(position, top, right, z-index,display, float等) 2.大小(width, height, padding, margin) 3.文字系列(font, line-height, letter-spacing,color- text-align等) 4.背景(background, border等) 5.其他(animation, transition等) 作者：知乎用户链接：https://www.zhihu.com/question/19586885/answer/48933504来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
